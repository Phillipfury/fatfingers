// Almost everything this does is catch and handle or dispatch click events:
document.addEventListener('click', handleClick, true);

var gChooser = null;
var gStyleElement = null;
var CLICKABLE_RADIUS = 75;
var UNCLICKABLE_RADIUS = 100;
var gLastSelected = null;

var STYLE = (
'#fatfingers-chooser {\n' + 
'  border: 3px solid #666;\n' +
'  -moz-border-radius: 3px; -webkit-border-radius: 3px; border-radius: 3px;\n' +
'}\n' +
'#fatfingers-chooser * {\n' +
'  background-color: #fff;\n' +
'  color: #000;\n' +
'}\n' +
'#fatfingers-chooser .fatfingers-selection {\n' +
'  cursor: pointer;\n' +
'  width: 100%;\n' +
'  overflow: hidden;\n' +
'  height: 2em;\n' +
'}\n' +
'#fatfingers-chooser .fatfingers-selection-inner {\n' +
'  padding: 4px;\n' +
'}\n' +
'#fatfingers-chooser .fatfingers-selection:hover {\n' +
'  background-color: #dfd;\n' +
'}\n' +
'#fatfingers-chooser .fatfingers-selection:hover * {\n' +
'  background-color: #dfd;\n' +
'}\n' +
'#fatfingers-chooser .fatfingers-selection:not(:last-child) {\n' +
'  border-bottom: 1px solid #666;\n' +
'}\n'
);


function handleClick(ev) {
  var target = ev.target;
  if (isChooser(target)) {
    console.log('letting chooser click through');
    return;
  }
  if (ev.artificial) {
    // This is an event generated by us
    return;
  }
  if (gChooser !== null) {
    console.log('click outside chooser while chooser is open');
    teardownChooser();
    ev.preventDefault();
    ev.stopPropagation();
    return;
  }
  if (gStyleElement === null) {
    setupStyle();
  }
  if (target.tagName == 'HEAD' || target.tagName == 'BODY') {
    console.log('Not a normal target', target);
    return;
  }
  var pos = [ev.clientX, ev.clientY];
  console.log(ev);
  var nearby = [];
  while (target && target.nodeType != document.ELEMENT_NODE) {
    target = target.parentNode;
  }
  if (gLastSelected == target) {
    // A click inside an already focused element
    console.log('Clicking inside last focused', gLastSelected);
    return;
  }
  if (! target) {
    console.log('somehow target fell away', ev.target);
    return;
  }
  if (clickable(target)) {
    var radius = CLICKABLE_RADIUS;
  } else {
    var radius = UNCLICKABLE_RADIUS;
  }
  makeTempCircle(pos, radius, 1000);
  findNearby(target, pos, nearby, radius, null, true);
  if (nearby.length <= 1) {
    // Let the standard handler take it
    if (! nearby.length) {
      console.log('Found no targets');
    } else {
      console.log('Only one target', nearby);
    }
    return;
  }
  ev.preventDefault();
  ev.stopPropagation();
  setupChooser(nearby, ev);
}

function setupStyle() {
  var gStyleElement = document.createElement('style');
  gStyleElement.appendChild(document.createTextNode(STYLE));
  document.head.appendChild(gStyleElement);
}

function setupChooser(options, ev) {
  if (gChooser !== null) {
    teardownChooser();
  }
  var evData = getEventData(ev);
  var div = document.createElement('div');
  div.id = 'fatfingers-chooser';
  div.style.position = 'fixed';
  div.style.top = '5em';
  div.style.left = '5em';
  div.style.right = '5em';
  //div.style.bottom = '5em';
  div.chooser = true;
  for (var i=0; i<options.length; i++) {
    var option = options[i];
    var selection = makeSelection(description(option));
    selection.option = option;
    selection.optionData = evData;
    // Maybe true instead of false here?
    selection.addEventListener('click', clickSelection, false);
    div.appendChild(selection);
  }
  var cancel = makeSelection('Cancel click');
  cancel.addEventListener('click', teardownChooser, false);
  div.appendChild(cancel);
  document.body.appendChild(div);
  gChooser = div;
  console.log('setup chooser');
}

function makeSelection(innerHTML) {
  var div = document.createElement('div');
  div.className = 'fatfingers-selection';
  var inner = document.createElement('div');
  inner.className = 'fatfingers-selection-inner';
  div.appendChild(inner);
  inner.innerHTML = innerHTML;
  return div;
}

function clickSelection(event) {
  var target = event.target;
  while (target && (! target.option)) {
    target = target.parentNode;
  }
  if (! target) {
    console.log('Click fell through from target', event.target);
    return;
  }
  var option = target.option;
  var data = target.optionData;
  teardownChooser();
  event.preventDefault();
  event.stopPropagation();
  clickElement(option, data);
}

function teardownChooser() {
  console.log('removing chooser');
  document.body.removeChild(gChooser);
  gChooser = null;
}

function clickElement(el, data) {
  console.log('processing click on', el, data);
  var event = createClick(el, data);
  event.artificial = true;
  var doDefault = el.dispatchEvent(event);
  if (doDefault) {
    // FIXME: return value matters here I think?
    if (el.onclick) {
      el.onclick(event);
      return;
    }
    if (el.tagName == 'A') {
      // FIXME: should handle anchors, javascript:?
      // FIXME: should handle target=X
      //location.href = el.href;
    } else if (el.tagName == 'INPUT') {
      var t = el.type.toLowerCase();
      if (t == 'checkbox' || t == 'radio') {
        //el.click();
      } else if (t == 'submit') {
        el.form.submit();
      } else {
        gLastSelected = el;
        el.focus();
      }
    } else if (el.tagName == 'SELECT' || el.tagName == 'TEXTAREA') {
      gLastSelected = el;
      el.focus();
    }
  }
};

function createClick(el, data) {
  var ev = document.createEvent('MouseEvents');
  ev.initMouseEvent(
    'click', // type
    true, // canBubble
    true, // cancelable
    window, // view
    data.detail,
    data.screenX,
    data.screenY,
    data.clientX,
    data.clientY,
    data.ctrlKey,
    data.altKey,
    data.shiftKey,
    data.metaKey,
    data.button,
    null // relatedTarget
  );
  return ev;
}

function getEventData(ev) {
  return {
    detail: ev.detail,
    screenX: ev.screenX,
    screenY: ev.screenY,
    clientX: ev.clientX,
    clientY: ev.clientY,
    ctrlKey: ev.ctrlKey,
    altKey: ev.altKey,
    shiftKey: ev.shiftKey,
    metaKey: ev.metaKey,
    button: ev.button
  };
}

function isChooser(el) {
  while (el) {
    if (el.chooser) {
      return true;
    }
    el = el.parentNode;
  }
  return false;
}

function findNearby(el, clickPos, result, radius, ignoreEl, traverseParent) {
  if ((! el.getClientRects) || (! el.getClientRects())) {
    return;
  }
  if (clickable(el)) {
    result.push(el);
  } else {
    // We'll traverse the children
    for (var i=0; i<el.childNodes.length; i++) {
      var child = el.childNodes[i];
      if (ignoreEl && child == ignoreEl) {
        continue;
      }
      if (child.nodeType != document.ELEMENT_NODE) {
        continue;
      }
      var childBox = getBox(child);
      if (childBox === null) {
        continue;
      }
      if (circleIntersectsBox(clickPos, radius, childBox)) {
        findNearby(child, clickPos, result, radius, null, false);
      }
    }
  }
  // encloses() tells us if this element is bigger than our search radius; if it
  // is then we need look no further
  var box = getBox(el);
  if (traverseParent && box !== null && (! encloses(clickPos, getBox(el), radius))) {
    var parent = el.parentNode;
    if (parent.tagName != 'HTML' || parent.tagName != 'HEAD') {
      findNearby(parent, clickPos, result, radius, el, true);
    }
  }
}

function encloses(pos, box, radius) {
  // FIXME: this is wrong, we need to calculate the hypotenuse
  return (box[0] < pos[0]-radius) &&
         (box[1] < pos[1]-radius) &&
         (box[2] > pos[0]+radius) &&
         (box[3] > pos[1]+radius);
}

function intersects(pos, box, radius) {
  return intersectPoint(pos, [box[0], box[1]], radius) ||
         intersectPoint(pos, [box[0], box[3]], radius) ||
         intersectPoint(pos, [box[2], box[1]], radius) ||
         intersectPoint(pos, [box[2], box[3]], radius);
}

function intersectPoint(center, point, radius) {
  return (center[0]-point[0])*(center[0]-point[0]) +
         (center[1]-point[1])*(center[1]-point[1]) < radius*radius;
}

function circleIntersectsBox(pos, radius, box) {
  /* Returns true if the box and circle intersect */
  /* Algorithm from here: http://hq.scene.ro/blog/read/circle-box-intersection-revised/ */
  if (pos[0] >= box[0] && pos[0] <= box[2] && pos[1] >= box[1] && pos[1] <= box[3]) {
    // The center of the circle is inside the box
    return true;
  }
  if (pos[0] >= box[0] && pos[0] <= box[2]) {
    // The center of the circle is above or below the box
    if (pos[1] < box[1]) {
      return pos[1]+radius > box[1];
    } else {
      return pos[1]-radius < box[3];
    }
  } else if (pos[1] >= box[1] && pos[1] <= box[3]) {
    // The center of the circle is left or right of the box
    if (pos[0] < box[0]) {
      return pos[0]+radius > box[0];
    } else {
      return pos[0]-radius < box[2];
    }
  } else {
    var x, y;
    if (pos[0] < box[0]) {
      x = box[0];
    } else {
      x = box[2];
    }
    if (pos[1] < box[1]) {
      y = box[1];
    } else {
      y = box[3];
    }
    return (pos[0]-x)*(pos[0]-x) + (pos[1]-y)*(pos[1]-y) < radius*radius;
  }
}


function getBox(el) {
  var rect = el.getClientRects()[0];
  if (! rect) {
    return null;
  }
  return [rect.left, rect.top, rect.right, rect.bottom];
}

function clickable(el) {
  /* Returns true if the element is clickable */
  var tag = el.tagName;
  if (tag === 'A' && el.getAttribute('name') && (! el.href)) {
    // Just a named anchor
    return false;
  }
  if (tag === 'A' || tag === 'BUTTON' || tag === 'SELECT' || tag === 'INPUT'
      || tag === 'TEXTAREA') {
    return true;
  }
  return false;
}

function description(el) {
  /* Given a clickable element, return the description of the element (in HTML) */
  var tag = el.tagName;
  if (tag === 'A') {
    var href = el.href;
    if (href) {
      href = formatLink(href);
    }
    if (href === '#') {
      href = '';
    }
    if (href) {
      return el.innerHTML + ': ' + htmlQuote(href);
    } else {
      return el.innerHTML;
    }
  }
  if (tag === 'BUTTON') {
    // FIXME: is the default submit?
    if (el.type.toLowerCase() == 'submit') {
      return 'Submit form (' + tag.innerHTML + ')';
    } else {
      return 'Click (' + tag.innerHTML + ')';
    }
  }
  if (tag == 'INPUT') {
    var t = el.type.toLowerCase();
    if (t == 'submit') {
      return 'Submit form: ' + htmlQuote(el.value);
    } else if (t == 'radio' || t == 'checkbox') {
      // FIXME: should try to get label
      return 'Select ' + htmlQuote(el.value) + ' from ' + formElementName(el);
    } else {
      // FIXME: also label
      return 'Enter text into ' + formElementName(el);
    }
  }
  if (tag == 'SELECT') {
    // FIXME: label
    return 'Make selections in ' + formElementName(el);
  }
  if (tag == 'TEXTAREA') {
    return 'Enter/edit text in ' + formElementName(el);
  }
  // FIXME: shouldn't happen
  throw 'Unknown tag: ' + tag;
}

function getLabel(el) {
  if (! el.id) {
    return null;
  }
  var els = document.getElementsByTagName('label');
  for (var i=0; i<els.length; i++) {
    if (els[i].getAttribute('for') == el.id) {
      return els[i];
    }
  }
  return null;
}

function formElementName(el) {
  return getLabelHtml(el) || htmlQuote(el.getAttribute('name') || el.id || el.tagName.toLowerCase());
}

function getLabelHtml(el) {
  el = getLabel(el);
  if (el !== null) {
    return el.innerHTML;
  } else {
    return null;
  }
}

function htmlQuote(t) {
  t = t + '';
  t = t.replace(/&/g, '&amp;');
  t = t.replace(/"/g, '&quot;');
  t = t.replace(/</g, '&lt;');
  return t;
}

function formatLink(href) {
  var base = location.href+'';
  var hash = '';
  if (base.indexOf('#') != -1) {
    hash = base.substr(base.indexOf('#'));
    base = base.substr(0, base.indexOf('#'));
  }
  if (href.indexOf(base) === 0) {
    if (href.indexOf('#') == -1) {
      return 'here';
    } else {
      return href.substr(href.indexOf('#'));
    }
  }
  // FIXME: do something with paths on the same domain
  return href;
}

function makeCircle(pos, radius) {
  var circle = document.createElement('div');
  circle.style.backgroundColor = 'transparent';
  circle.style.border = '2px solid #f00';
  circle.style.position = 'fixed';
  circle.style.width = (radius*2) + 'px';
  circle.style.height = (radius*2) + 'px';
  circle.style.borderRadius = radius + 'px';
  circle.style.top = (pos[1] - radius) + 'px';
  circle.style.left = (pos[0] - radius) + 'px';
  document.body.appendChild(circle);
  return circle;
}
  
function makeTempCircle(pos, radius, time) {
  var circle = makeCircle(pos, radius);
  setTimeout(function () {
    document.body.removeChild(circle);
  }, time);
}
